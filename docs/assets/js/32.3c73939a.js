(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{180:function(n,t,e){"use strict";e.r(t);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git","aria-hidden":"true"}},[n._v("#")]),n._v(" git")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n版本控制系统是用来记录项目修改历史的\n和git类似的还有SVN SVN是一个集中式的版本控制系统\n区别：\nGIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。\n\n如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。\n\nGit 与 SVN 区别点：\n\n1、GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。\n\n2、GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。\n\n3、GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。\n\n4、GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。\n\n5、GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n\ngit config --global user.name xxxx 全局配置用户名\ngit config --global user.email xxxx 全局配置邮箱\ngit config --list 查看全局配置 \n\ngit init 初始化一个本地版本库\ngit status 查看工作区和暂存区状态\n工作区的修改提交到本地版本库需要两部\n第一步：git add . 把工作区所有的修改提交到暂存区\n第二步：git commit -m '描述'把暂存区的修改提交到本地版本库\n\ngit add 指定文件名 filename1 filename2\ngit log 查看历史记录\ngit reflog 查看所有的历史记录\nls 查看当前文件夹下有哪些文件\ncd 进入某一个文件 cd..退出\nclear 清屏\ncat 文件名 查看文件内容\ngit diff 查看工作区具体修改\ngit diff --cached 查看暂存区具体的修改\n\nq 退出\n\n撤销：\n\t1、撤销工作区的修改 git checkout -- index.html(文件名)\n\t2、撤销暂存区的修改 \n\t\t第一步：先把修改从暂存区撤回到工作区\n\t\t\tgit reset index.html(文件名)\n\t\t第二步：撤销工作区的修改\n\t\t\tgit checkout -- index.html(文件名)\n\t3、版本回退 \n\t\t\tgit reset --hard HEAD^ 回退到上一个版本\n\t\t\tgit reset --hard HEAD^^ 回退到上上个版本\n\t\t\tgit reset --hard commit_id 回退到指定版本\n\n\ngithub\ngitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。\ngithub 支持两种传输协议 https和ssh\n\tssh协议需要配置公钥和秘钥\n\thttps协议需要用户名密码\ngit clone 仓库的地址 克隆远程仓库\n.gitignore 设置忽略文件\ngit push origin master 把本地版本库的修改提交到远程\ngit remote add origin 仓库地址 把本地仓库和远程仓库关联起来\ngit remote -v 查看关联的远程仓库是否成功\ngit pull origin master 从远程拉取代码到本地\n\necho '# new'>>README.md \ngit init  git add README.md git commit -m \n\n分支：\ngit branch 分支名  新建一个分支\ngit branch 查看本地分支\ngit branch -a 查看所有的分支\ngit branch -r 查看远程分支\ngit checkout 分支名 切换分支\ngit branch -D 分支名 删除没有合并的分支\ngit branch -d 分支名 删除                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n分支\ngit cheackout -b 分支名 创建并切换分支\n<<<<<<< HEAD ===== >>>>>>> 冲突 ===> 手动解决\n\ngit merge 分支名(dev) 确保你现在所在的master,把dev分支合并到master分支\n\n\n")])])]),e("h2",{attrs:{id:"团队合作开发步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#团队合作开发步骤","aria-hidden":"true"}},[n._v("#")]),n._v(" 团队合作开发步骤")]),n._v(" "),e("p",[e("img",{attrs:{src:"/step1.png",alt:"步骤一"}}),n._v(" "),e("img",{attrs:{src:"/step2.png",alt:"步骤二"}}),n._v(" "),e("img",{attrs:{src:"/step3.png",alt:"步骤三"}})]),n._v(" "),e("h3",{attrs:{id:"gulp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gulp","aria-hidden":"true"}},[n._v("#")]),n._v(" gulp")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("gulp是一个前段自动化构建工具 基于node体系\n优点：易于使用、构建快速、插件高质、易于学习\n\n安装：\n\t全局安装gulp4.0：npm install gulp@next --global \n\t全局安装gulp-cli:npm install gulp-cli --global\n\t本地安装：npm install gulp@next --save-dev\n    \n    在项目根目录下建立一个gulpfile.js的文件\n    \n引入：var gulp=require('gulp');\n\n=====\ngulp的api\n1、gulp.task(任务名,回调函数)  建gulp任务\n\t任务名：default ,执行：gulp\n\t任务名：task,执行：gulp task\n2、gulp.src(读取文件的规则,[opt]) \n\t有一个pipe()方法\n\t规则：必须为字符串或数组\n\t\t* 匹配所有的文件\n        ** 匹配0个或多个文件夹\n        {jpg,png} 或\n        ! 非 不匹配\n\t第二个参数可选,必须为对象 {base:'src'}\n3、gulp.dest(输出的文件目录) 输出文件\n\n插件：gulp-sass 编译sass\n\t引入：var sass=require('gulp-sass');\n\tgulp.task('sassTask',function(){\n  \t\treturn gulp.src('./src/sass/*.scss')\n  \t\t\t.pipe(sass())\n  \t\t\t.pipe(gulp.dest('./src/css'))\n\t});\n\tgulp.task('watch',function(){\n\t\treturn gulp.watch('./src/sass/*.scss',gulp.series('sassTask'))\n\t});\n监听：gulp.watch();\n\ngulp任务的执行顺序是异步的 \ngulp.series(task1,task2...);串行执行\ngulp.parallel(task1,task2...);并行执行\n\n压缩css gulp-clean-css\nvar minCss=require('gulp-clean-css')\n压缩js gulp-uglify\nvar uglify=require('gulp-uglify');\n\n起服务插件gulp-webserver\n\tserver({\n  \t\tport:9090, 配置端口号\n  \t\thost:'169.254.204.130', 配置ip\n  \t\tlivereload:true, 自动刷新浏览器\n  \t\topen:true, 自动打开浏览器\n  \t\tfallback:'demo.htm',配置默认打开的文件\n  \t\tmiddleware:function(req,res,next){\n  \t\t\t\n\t\t},拦截前端请求\n\t})\n\t\ngulp-babel ES6插件\nbabel-preset-es2015必须下载\n\n.pipe(babel({\n  \tpresets:[\"es2015\"]\n}))\n\ngulp-autoprefixer 自动添加前缀插件\ngulp-concat 合并文件\ngulp-clean 删除文件\ngulp-htmlmin 压缩html\ngulp-rev 添加后缀MD5\ngulp-rev-collector 替换文件\n")])])]),e("h3",{attrs:{id:"browserify"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#browserify","aria-hidden":"true"}},[n._v("#")]),n._v(" browserify")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Browserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，通过预编译让前端 Javascript 可以直接使用 Node NPM 安装的一些库。\n\n可以进行模块化开发 基于node体系,不是基于gulp体系\n\nvar browserify=require('browserify');\n\n//转换流\nvar source=require('vinyl-source-stream');\nvar buffer=require('vinyl-buffer');\n\n//读取调试\nvar sourcemaps=require('gulp-sourcemaps') ;\n//合并文件流\nvar merge2=require('merge2');\n//重命名文件\nvar rename=require('gulp-rename');\n\ngulp.task('bundle',function(){\n  \tvar fileArr=['./src/js/index.js','./src/js/detail.js'];\n  \tvar streamArr=fileArr.map(function(entry){\n  \t\treturn browserify({\n          entries:'./src/js/index.js' ,//入口文件\n          debug:true\n        }).bundle() //返回的是node普通的文件流\n        .pipe(source('bundle.js'))\n        .pipe(buffer())\n        .pipe(rename({\n  \t\t\textname:'.bundle.js',\n  \t\t\tdirname:''\n\t\t}))\n        .pipe(sourcemaps.init({loadMaps:true}))\n        .pipe(sourcemaps.write()) //写入路径\n        .pipe(gulp.dest('./src/js/bundle'))\n\t})\n\treturn merge2(streamArr)\n})\n\n")])])]),e("h3",{attrs:{id:"require-js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#require-js","aria-hidden":"true"}},[n._v("#")]),n._v(" require.js")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("requirejs是一个js模块载入框架 遵循AMD规范 ==>异步加载规范\n\nnodejs 遵循commonjs规范 ==>同步加载规范\n\n好处：\n\t1、解决了文件之间的依赖\n\t2、异步加载，不会阻塞页面的加载\n\nApi:requirejs、require、define\n\trequirejs===require\n用法：\n\trequire([依赖模块名],function(){//载入模块\n\t})\n\t第一个参数：数据类型array [模块1，模块2]\n\t第二个参数：回调函数 执行代码\n\t\n\tdefine(模块名,[],function(){\n  \t\treturn\n\t});\n\t第一个参数：模块名 数据类型string 一般不写\n\t第二个参数：依赖的模块 数据类型array 即使只有一个依赖模块也必须为数组\n\t第三个参数：回调函数 要执行的代码\n\nasync=\"true\" 设置requirejs 为异步加载 ie为defer\ndata-main 指定项目主入口文件\nrequire.config({ //配置\n\tbaseUrl:'/js/', 配置基准路径 绝对路径 需要起服务\n  \tpaths:{\n  \t\t'jquery':'./libs/jquery-3.3.1.min', \n  \t\t'index':'./page/index' //不能加.js后缀\n\t},\n\tshim:{\t//配置不符合AMD规范的\n\t\t'util':{\n  \t\t\t// export:'sum' 只导出一个\n  \t\t\tinit:function(){ //导出多个\n  \t\t\t\treturn {\n  \t\t\t\t\tsum:sum,\n  \t\t\t\t\tmin:min\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeps:['jquery'] //设置依赖\n\t\t}\n\t}\n});\nrequire['index']\n路径查找规则：\n\t1、在页面引入模块，路径相对于页面的路径去查找\n\t2、如果指定了path和主入口文件，要相对于主入口文件查找\n\t3、如果指定了baseUrl，路径相对于baseUrl路径查找\n\nhttp-server 起一个小型服务 \n\tnpm install http-server -g\n\thttp-server -p 端口号\n\t\n\n")])])]),e("h3",{attrs:{id:"handlebars"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#handlebars","aria-hidden":"true"}},[n._v("#")]),n._v(" handlebars")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。\n\nhandlebars表达式 以{{开始，以}}结尾\n\n循环:\n{{#each 数组}} \n\n{{/each}}\n\n../访问父级  . 访问子级\n\n{{!单行注释内容}}\n{{!--多行注释内容--}}\n\n注册帮助：一定要放在获取数据之前\n{{addIndex @index}}\nHandlebars.registerHelper(\'addIndex\',function(index){\n  \treturn index+1\n})\n\n{{#if true/false}}\n\t条件为真显示\n\t{{else}}\n\t条件为假显示\n{{/if}}\n\n{{#unless true/false}}\n\t条件为假显示\n\t{{else}}\n\t条件为真显示\n{{/unless}}\n\n{{#with this指向}}\n{{/with}}\n\n<script src="handlebar.js"><\/script>\n<script id="tpl" type="text/x-handlebars-template">\n    <div class="entry">\n      <h1>{{title}}</h1>\n      <div class="body">\n        {{body}}\n      </div>\n\t</div>\n<\/script>\n第一步：获取handlebars模板\nvar source=$(\'#tpl\').html();\n第二步：编译模板\nvar template=Handlebars.compile(source);\n第三部：传入数据\nvar context = {title: "My New Post", body: "This is my first post!"}\nvar html    = template(context);\n第四步：渲染页面\n$(\'.warp\').html(html)\n\n')])])])])}],!1,null,null,null);t.default=s.exports}}]);