(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{166:function(n,e,t){"use strict";t.r(e);var r=t(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("h3",{attrs:{id:"nodejs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nodejs","aria-hidden":"true"}},[n._v("#")]),n._v(" nodejs")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('什么是Node.js?\nNode.js是基于 chrome V8引擎的 JavaScript 运行环境 \n\t特点：速度快、性能好、单线程、跨平台、事件与回调函数\nNode.js使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。\nNode.js使用的是commonjs规范\nNode.js 的包管理器 npm，是全球最大的开源库生态系统。\n包管理文件 package.json 包含了当前项目的一些描述信息,通过npm init 命令来创建\nnpm 官网下载包 www.npmjs.com\n国内访问国外网站比较慢,解决方案是通过淘宝镜像去访问\n安装npm npm install 安装npm包命令 -g 全局安装 --save本地 -dev添加到dev版本项目依赖\n设置全局包安装路径 npm config set prefix \n设置全局包缓存路径 npm config set cache \n查看路径目录 npm root 全局 npm root -g\n\texports 导出对象\n如何打开npm默认配置 npm config ls\n\n如何执行node.js\n1、node index.js\n2、node 路径\n3、node console.log()\n\n配置环境变量 可以让某一个命令在当前系统下任意路径访问\n配置访问全局包的环境变量  NODE_PATH 路径目录\n\n什么是msi与exe? ==> 执行安装(傻瓜式安装,自动添加环境变量)  \n\tzip ==> 绿色安装(手动拷贝目录,手动添加环境变量)\nmsi是Windows installer开发出来的程序安装文件,它可以让你安装,修改,卸载你所安装的程序.说白了msi就是Windows installer的数据包,把所有和安装文件相关的内容封装在一个包里了.\nsetup.exe也允许你安装程序,但程序员在开发setup.exe的时候要比开发setup.msi困难的多,需要人工编写和安装,修改,卸载相关的很多内容.而msi把这写功能都集成化了,易于开发WINDWOS程序安装包\n\npackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成。\npackage.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\n\npackage.json文件配置详解{\n\tname:项目名称\n\tversion:版本信息\n\tdescription:模块描述,或者搜索\n\tmain:指定了加载的入口文件\n\tscripts:指定了运行脚本命令的npm命令行缩写{\n  \t\t"start":"node index --inline --hot --progress"\n\t\t}\n\trepository:指定一个代码存放地址(仓库)\n\tdevDependencies:指定项目开发所需要的模块\n\tdependencies:指定项目运行所依赖的模块\n\t}\nnpm run start\n')])])]),t("h2",{attrs:{id:"commonjs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#commonjs","aria-hidden":"true"}},[n._v("#")]),n._v(" CommonJs")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("https://www.cnblogs.com/chenguangliang/p/5856701.html\n\nAMD 和 CMD 的区别有哪些？\n\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\nCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。\n\n类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。\n\n还有不少⋯⋯\n\n这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。\n\n目前这些规范的实现都能达成浏览器端模块化开发的目的。\n\n区别：\n\n1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n2. CMD 推崇依赖就近，AMD 推崇依赖前置\n\n3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。\n\n4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。\n\nCommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。\n\n在兼容CommonJS的系统中，你可以使用JavaScript开发以下程序： \n\n(1).服务器端JavaScript应用程序\n\n(2).命令行工具\n\n(3).图形界面应用程序\n\n(4).混合应用程序（如，Titanium或Adobe AIR）\n\nnode.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。\n\nvar math = require('math');\n\n然后，就可以调用模块提供的方法：\n\n　　var math = require('math');\n\n      math.add(2,3); // 5\n\nCommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}\n\nrequire()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。\n\n1、原理\n\n浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。\n- module\n- exports\n- require\n- global\n只要能够提供这四个变量，浏览器就能加载 CommonJS 模块。\n\n2、Browserify 的实现\n\n知道了原理，就能做出工具了。Browserify 是目前最常用的 CommonJS 格式转换的工具。\n\n3、Tiny Browser Require\n\n虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。\n\n我根据 mocha 的内部实现，做了一个纯浏览器的 CommonJS 模块加载器 tiny-browser-require 。完全不需要命令行，直接放进浏览器即可，所有代码只有30多行。\n\n它的逻辑非常简单，就是把模块读入数组，加载路径就是模块的id。\n\nmodule.exports 在模块抛出\nexports.名称=方法 \n\nrequire() 主模块引入 1、内置模块 2、外置模块 3、自定义模块\n\n模块加载机制：\n当前目录==>父级目录==>磁盘根节点\n\n为什么可以不写index.js\nnodejs 找文件规则，给出一个文件夹路径，默认会找该文件夹的index.js\n如果引用路径不想写./ 需要将自定义模块放到node_modules\n可以通过package.json 的main 属性来指定入口文件名称\n")])])]),t("h3",{attrs:{id:"npm包发布"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npm包发布","aria-hidden":"true"}},[n._v("#")]),n._v(" npm包发布")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("npm adduser   \nnpm publish\n")])])]),t("h3",{attrs:{id:"文件拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件拷贝","aria-hidden":"true"}},[n._v("#")]),n._v(" 文件拷贝")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1、小文件拷贝\nfs模块 文件系统模块  用来操作系统文件 内置模块\nfs.readFile(filename,[encoding],[callback]);\n路径 回调函数(err,data) data 默认返回一个buffer\nfs.writeFile(目标文件路径，数据，回调函数)\nfs.appendFile(dir,data,function(err){}) 只追加 不替换\n\npath模块 路径处理模块 内置模块\npath.normalize()将一个路径格式化成一个标准路径\npath.join()将多个路径合并成一个路径 \n\n\n2、大文件拷贝\nfs.createReadStream(原文件路径)\nfs.createWriteStream(目标文件路径)\n原文件流.pipe(目标流)\n\n3、文件判断\nfs.stat(文件路径,function(err,stat){})\n\tstat.isFile() 判断是不是文件\n\tstat.isDirectory()判断是不是文件夹\n\n4、事件发射器\nStream基于事件机制工作，所有Stream的实例都继承于NodeJS提供的EventEmitter。\n\n5、chunk 代表一个数据块\n当有数据流流入的时候可以做两个操作\npause() 暂停 resume() 恢复\n\n    var rs = fs.createReadStream(src);\n\n    rs.on('data', function (chunk) {\n        rs.pause();\n        doSomething(chunk, function () {\n            rs.resume();\n        });\n    });\n\t\n    rs.on('end', function () {\n        cleanUp();\n    });\n以上代码给doSomething函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。\nws.drain事件表示只写数据流已经将缓存中的数据写入到目标，可以传递下一段待写数据\n此外，我们也可以为数据目标创建一个只写数据流，示例如下：\nvar rs = fs.createReadStream(src);\nvar ws = fs.createWriteStream(dst);\n\nrs.on('data', function (chunk) {\n    ws.write(chunk);\n});\n\nrs.on('end', function () {\n    ws.end();\n});\n\n6、path.join();只能用来合并路径\n   path.extname();返回文件后缀\n   \t如果路径中没有 . 或只有一个 . 或以 . 开头，则返回空字符\t串 如果以 . 结尾 则返回 . \n   \n   path.basename();返回路径的最后一部分 \n   \t\t第二个参数写了 会返回去掉后缀的前半部分\n   path.dirname();返回代表文件夹的部分\n   path.resolve(); 将一系列路径或路径段解析为绝对路径 \n   如果不传参的话返回当前工作目录 \n   如果在处理给定path段之后，还没有生成绝对路径，则使用当前目录进行追加\n   从右往左依次追加，找到绝对路径就停止追加 直接返回\n   __dirname 当前js文件所在的绝对路径\n   path.isAbsolute()判断是不是一个绝对路径\n   path.relative(); 得到一个从哪到哪的相对路径\n   path.sep();解决跨平台路径\"/\" \"\\\" 等路径问题 得到当前系统的分隔符\n   path.parse()转对象  拆分\n       {\n      root:根\n      dir:最后一个文件夹的部分\n      base:文件部分\n      ext:文件后缀\n      name:文件名（不含后缀）\n    }\n   path.format()转字符串 拼接 \n     如果有dir会忽略root\n     如果有base会忽略ext和name\n     path=path.dirname+path.basename\n   \n7、fs.mkdir(dir,function(err){});\n\tfs.mkdirSync(dir,function(err){});\n\tfs.readdir(dir,function(err,paths){});\n\t\tpaths是读取到的文件集合\n\t\n\t判断文件或者文件夹是否存在的方法\n\tfs.exists(dir/file,function(exist){}) \n\t\texist是一个布尔值\n8、process.argv 当前命令行执行命令集合\n\tprocess.cwd()返回当前的工作目录==path.resolve()\n")])])]),t("h3",{attrs:{id:"http"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http","aria-hidden":"true"}},[n._v("#")]),n._v(" http")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("http 是一个操作服务的内置模块\nvar http=require(\"http\");\n服务器 (被请求的一方,接收请求,做出响应)\n服务器地址=协议(http/https)+域名(www.baidu.com)+端口(默认80)+路径(/src)+[地址栏参数?xx==oo&aa==bb]\neg: http://localhost:8080/path?id=1&num=2\n\n客户端 (发出请求的一方)\n\t\n\thttp.createServer(function(request,response){\n      //接收请求、处理请求、做出响应\n      \t当客户端发起访问时 callback 才执行  执行次数跟客户端的请求次数有关\n        request==>客户端向服务器发送请求的对象\n        response==>服务器向客户端响应的对象\n    }).listen(8080)\n    //所有的请求路径都以 / 开头\n    // request.url=path(路径)+search(地址栏参数)  \n    // request.method(请求方式 GET | POST)\n    // response.writeHead(状态码,{\n  \t\t\t'Content-Type':'text/plain'(存文本) || 'tetx/html' \n\t\t}) 设置响应头信息\n    // response.write()\n    // response.end()\n    \n1、搭建服务器步骤\n\t引入模块==>创建服务http.createServer(function(req,res){})==>设置响应头信息(可省略)\n\tres.writeHead(状态码,{\n  \t\t\t'Content-Type':'text/plain'(纯文本) || 'tetx/html' || text/css || text/javascript || application/json  image/png image/gif  ....\n\t}) \n\t==>设置响应内容(可省略) res.write(str/buffer)  Buffer.from()可以创建一个Buffer\n\t\tBuffer.concat([buf1,buf2]) 可以拼接buffer\n\t==>结束响应 res.end(str/buffer)\n\t==>监听端口号server.listen(端口号,callback);\n\t\n\t\n\ttry{\n  \t\t//放入可能会发生同步异常的代码块\n\t}catch(e){\n  \t\t//e就是捕捉到的异常\n\t}\n\t\n\t当把html文件放到服务器下时，在该文件中发起的所有请求都会默认去该服务器下加载\n\t\nhttp.request() http.get()\n都是向本地或远程的服务器请求数据\nhttp.request(服务器地址,function(res){\n  //当服务器做出响应时执行的回调\n  //用于接收服务器响应的数据\n  \tvar str='';\n  \tres.on('data',function(chunk){\n  \t\tstr+=chunk.toString();\n\t});\n\tres.on('end',function(){\n  \t\tconsole.log(str)\n\t})\n}).end();\n\nhttp.get(服务器地址,function(res){\n  res.on('data',function(chunk){\n  \t\tstr+=chunk.toString();\n\t});\n\tres.on('end',function(){\n  \t\tconsole.log(str)\n\t})\n});\n\nres.headers['content-encoding']告诉客户端返回的是个被gzip算法压缩的文件\n")])])]),t("h3",{attrs:{id:"前后端交互"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前后端交互","aria-hidden":"true"}},[n._v("#")]),n._v(" 前后端交互")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("form表单\n\n1、get方式\n\t通过地址栏参数传递\n\n2、post方式\n  req.setEncoding('utf-8');\n  var str='';\n  req.on('data',function(chunk){\n\t\tstr+=chunk;\n  });\n  req.on('end',function(){\n\t\n  });\n  \najax请求\n\tres.writeHead(200,{\n\t\t'Access-Control-Allow-Origin':'*'\n        设置服务器接受所有客户端发起的跨域访问  \n\t});\n\tif(req.url==\"/favicon.ico\"){\n    \treturn\n    }\n    res.end(fs.readFileSync('./www'+req.url));\n")])])]),t("h3",{attrs:{id:"querystring模块-url模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#querystring模块-url模块","aria-hidden":"true"}},[n._v("#")]),n._v(" querystring模块   url模块")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("querystring模块用于实现url参数字符串与参数对象的相互转换,以及对参数进行解码/编码\nvar querystring=require('querystring');\n\tquerystring.parse()转对象 如果传递的键名相同键值不同 则键值生成一个数组\n\tquerystring.stringify()转字符串 \n\tquerystring.escape() 字符串编码\n\tquerystring.unescape() 字符串解码\n\n\nurl模块允许解析url,生成url,以及拼接url\n\tvar address=http://localhost:8080/path?name=zs&age=20\n\n\turl.parse(address,false/true) 生成一个对象\n\t第二个参数为true的作用是将query由一个string转成一个object\n\t属性：protocol  http:\n\t域名：hostname localhost\n\t端口：port 8080\n\t服务器名称：host=hostname+port\n\t路径：pathname /path\n\t参数：query name=zs&age=20\n\tsearch = ? + query\n\tpath = req.url = pathname+?+query\n\t\n\turl.format() 生成一个url路径\n")])])]),t("h3",{attrs:{id:"zlib模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zlib模块","aria-hidden":"true"}},[n._v("#")]),n._v(" zlib模块")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var zlib=require('zlib') 负责文件的压缩/解压的内置模块\n//压缩\nzlib.gzip(要压缩的文件内容,function(err,decoded){\n});\n//解压\nzlib.unzip(要解压的文件内容,function(err,decoded){\n});\n//创建一个压缩流 tranform流\nzlib.createGzip();\n\nvar rs=fs.createReadStream();\nvar ws=fs.createWriteStream();\nvar zip=zlib.createGzip();\nrs.pipe(zip).pipe(ws)\n\n//创建一个解压流\nzlib.createGunzip()\n")])])]),t("h3",{attrs:{id:"string-fromcharcode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-fromcharcode","aria-hidden":"true"}},[n._v("#")]),n._v(" String.fromCharCode()")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("返回一个大写字母 a-z \n生成一个随机4位大写字母\nvar arr=[];\nfor(var i=0;i<4;i++){\n  var num=Math.floor(Math.random()*26)+65;\n  arr.push(String.fromCharCode(num))\n}\n")])])]),t("h3",{attrs:{id:"socket-io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#socket-io","aria-hidden":"true"}},[n._v("#")]),n._v(" socket.io")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("socket.io  用于浏览器和服务器进行双工通讯(实时通讯)\n没有socket.io之前 浏览器和服务器通过定期轮询来进行双工通讯\n\n首先下载socket.io 包  npm install socket.io -save\nvar http=require('http');\nvar socketIo=require('socket.io');\nvar server=http.createServer(function(req,res){}).listen(8080);\nvar io=socketIo.listen(server);//会拦截以/socket.io开头的路径请求\n//当客户端与服务器建立连接时触发\nio.on('connection',function(socket){\n\t//向浏览器发送事件\n  \tsocket.send('hello');\n  \t//接收浏览器事件\n  \tsocket.on('message',function(data){\n        console.log(data)\n    });\n    //浏览器断开触发事件\n    socket.on('disconnect',function(){\n  \t\tconsole.log('浏览器关闭');\n\t});\n\t//服务器向浏览器派发一个自定义事件  只派发给自己\n\tsocket.emit(自定义事件名,要发送的内容1,要发送的内容2...)\n\t//服务器接收浏览器派发的自定义事件\n\tsocket.on(自定义事件名,function(data){\n  \t\tconsole.log(data);\n\t});\n\tsocket.broadcast.emit() 广播给除自己之外的客户端\n\tio.emit() 派发给双方\n})\n\n\n<script src=\"socket.io/socket.io.js\"><\/script>\n<script>\n\t//客户端与服务器建立连接\n\tvar socket=io.connect('http://localhost:8080');\n\t//接收服务端事件\n\tsocket.on('message',function(data){\n  \t\tconsole.log(data);\n\t});\n\t//向服务端发送事件\n\tsocket.send(data);\n\t//服务器断开触发事件\n\tsocket.on('connect',function(){\n  \t\tconsole.log('服务器断开');\n\t});\n\t//浏览器接收服务器派发的自定义事件\n\tsocket.on(自定义事件名,function(data){\n  \t\tconsole.log(data)\n\t});\n\t//浏览器向服务器派发自定义事件\n\tsocket.emit(自定义事件名,要发送的内容1,要发送的内容2...);\n<\/script>\n")])])]),t("h3",{attrs:{id:"进程模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程模块","aria-hidden":"true"}},[n._v("#")]),n._v(" 进程模块")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("参考文件：https://www.cnblogs.com/zmxmumu/p/6179503.html\n\nprocess 主进程\nchild_process 子进程\ncluster 多进程\n\nprocess.pid 当前主进程的进程号\nprocess.cwd() 执行当前文件的绝对路径\nprocess.argv 当前进程命令行参数数组\nprocess.stdout 指向标准输出\nprocess.stdin 指向标准输入\nprocess.stderr 指向错误输入\nprocess.exit()\n\non('exit') on('uncaughtException') on('SIGINT')\n//主进程退出事件\nprocess.on('exit',function(code){\n  code==1 程序异常退出\n  code==0 程序正常退出\n  console.log(code)\n});\n//捕捉全局异常 异常发生之前的所有代码都能执行\nprocess.on('uncaughtException',function(err){\n  \tconsole.log(err.message)\n});\n//信号事件 ctrl+c触发\nprocess.on('SIGINT',function(){\n  \tconsole.log('您将退出程序...');\n  \tsetTimeOut(function(){\n\t\tprocess.exit()  \n\t},1000)\n});\n//查看模拟数据\nprocess.stdout.write(str/buffer);\n//清空\nprocess.stdout.clearLine();\n//\nprocess.stdout.cursorTo(偏移量==>字节)\n\n============================================\n子进程是用来执行程序分配的任务(js文件,命令脚本)\nvar childProcess=require('child_process');\nvar worker=childProcess.fork(要执行的js文件);\nvar worker=childProcess.fork(要执行的js文件);\nworker.pid ==>子进程ID 随机分配的\nworker.on('exit',function(code){\n    code==1 程序异常退出\n    code==0 程序正常退出\n    console.log(code)\n});\n\n\nfunction createFork(){\n  var worker=childProcess.fork(要执行的文件);\n  worker.on('exit',function(code){ \n  \tif(code==1){\n  \t\tcreateFork();\n\t}else{\n  \t\tconsole.log('任务完成')\n\t}\n  }    \n}\n\n______________________________\n\n//运行shell脚本==>cmd命令\nvar worker=childProcess.spawn(command,[arg],opt);\n//捕捉标准输出流到控制台\nworker.stdout.on('data',function(chunk){\n  \tconsole.log(chunk.toString())\n});\n//捕捉错误输出流到控制台\nworker.stderr.on('data',function(chunk){\n  \tconsole.log(chunk.toString())\n});\n\n//根据命令个数创建子进程,守护子进程\nvar childProcess=require('child_process');\nvar arr=['a','b'];\nfunction createFork(file){\n  var worker=childProcess.spawn('node',[file],{cwd:'./lib'});\n  \tworker.stdout.on('data',function(chunk){\n  \t\tconsole.log(chunk.toString())\n\t});\n    worker.stderr.on('data',function(chunk){\n  \t\tconsole.log(chunk.toString())\n\t});\n\tworker.on('exit',function(code){ \n      if(code==1){\n          createFork(file);\n      }else{\n          console.log('任务完成')\n      }\n  \t}\n}\narr.forEach(function(file){\n  \tcreateFork(file)\n})\n\n————————————————————————————\n可以更高级的指令\nchildProcess.exec('command+argv',[opt],function(err,stdout,stderr){\n  终端有输出值时触发此函数\n})\n\nchildProcess.exec('node a',{cwd:'./lib'},function(err,stdout,stderr){\n  \n});\n\n=====================================\ncluster 多进程模块 合理利用多核cpu 实现http负载均衡 用来处理服务器并发请求\n\ncluster.fork() 创建子进程\n\nvar cluster=require('cluster');\nvar os=require('os');\nif(cluster.isMaster){\n\tos.cpus().forEach(function(){\n       cluster.fork()\n    });\n    console.log(cluster.workers);//顺序创建\n    console.log(Object.keys(cluster.workers));\n    cluster.on('listening',function(worker,address){\n  \t\tconsole.log(worker.id)\n  \t\tconsole.log(address.port)\n\t})\n}else if(cluster.isWorker){\n  \tconsole.log('子进程 id'+cluster.worker.id)//随机分配 子进程数据不共享\n  \trequire('http').createServer(function(req,res){\n  \t\tres.end('hh');\n\t})\n}\n\n-----------\n主进程监听事件 子进程请求时触发\ncluster.on('listening',function(worker,address){\n  \n})\n\nab.exe 可以对服务器进行压力测试\nab -n 1000 -c 10 localhost:8080\n相当于10个人向服务器同事发起请求，并发起了1000次\n\nr语言 可以测试每条进程所分配到的请求数\n1.输入r,键入r语言的执行环境\n2. df<-read.table(file='server.log',skip=9,header=FALSE)\n3.summary(df)\n")])])]),t("h3",{attrs:{id:"express"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#express","aria-hidden":"true"}},[n._v("#")]),n._v(" express")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Express 是一个完全由路由和中间件构成的web开发框架(非侵入式)\n1、下载+引入\n\tnpm init 生成package.json \n\tnpm install express -S\nvar express=require('express');\n2、实例化\nvar app=express(); //application应用\n3、注册路由 (get,post,all)\napp.get('/',function(req,res,next){ \n  res.end('hello /');\n});\napp.get('/user',function(req,res){ //处理器函数\n  res.end('hello user');\n});\napp.get('/pwd',function(req,res,next){ \n  next();// 移交控制权给下一个处理器函数或下一个同名路由\n  //next('route')==>跳过当前处理器函数，直接将控制权移交给下一个同名路由\n},function(req,res){\n  res.send('hello2')\n},function(req,res){\n  res.send('hello3')\n});\n//  /ab?cd ==>匹配b 0-1 \n\t/ab+cd ==>匹配b 1-多\n\t/ab*cd ==>匹配ab开头 cd结尾的路径\n\t'*' ==> 匹配所有路径\n\t/a/ ==>匹配路径中含有a的字符\n    \n\t'/user/:name/:pwd'==>加冒号 2级路径 可改\n\t路由路径参数 ==> req.params\napp.all()==>匹配所有方法\napp.all()是一个特殊的路由方法,没有任何HTTP方法与其对应,它的作用是对于一个路径上的所有请求加载中间件(函数)\n4、监听端口号\nvar server=app.listen(8899,function(){\n  console.log(server.address().port)\n});\n\n路由(Routing)是有一个URL(或者叫服务端路径)和一个特定的http方法(get post等)组成的，涉及到应用如何响应客户端对某个网站节点(请求路径)的访问，它的结构如下： app.METHOD(path, [callback...], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。\n\n如何响应:当路由匹配时会执行回调函数,对客户端做出响应\n路由匹配:\n\t1、客户端的路径===服务器的路径\n\t2、客户端的请求方式===服务器的方式\n\t\napp.get('/src/:name',function(req,res,next){ \n\tconsole.log(req.url) //整体路径\n\tconsole.log(req.path) //代表路径的部分\n\tconsole.log(req.query) //?后面的地址栏参数\n\tconsole.log(req.params); //冒号后面的\n\tres.status(404) //设置响应状态码\n\tres.setHeader('content-type','text/plain;charset=utf-8')\n\tres.writeHead(200,{\n  'content-type':'text/plain;charset=utf-8'\n})\n\tres.header('content-type','text/plain');//独有 可以多次设置\n\t//res.status(404).res.end('hello') 可以链式调用\n  \tres.end('hello');\n  \t\n  \tres.download() //提示下载文件\n  \tres.json() //发送一个JSON格式的响应\n  \tres.jsonp() //发送一个JSONP的JSON格式的响应\n  \tres.redirect() //重定向请求\n  \tres.render() //渲染视图模板\n  \tres.send() //发送各种类型的响应 如果传数值代表打印状态码\n  \tres.sendStatus() //设置响应状态码,并将其以字符串格式作为响应体的一部分发送\n  \t//res.sendFile(文件的绝对路径) //以八位字节流的形式发送文件\n});\n\napp.route(服务器端路径).method1(ck).method2(ck);\n创建由路径的[链式]路由句柄,由于路径在一个地方指定,有助于创建模块化路由,减少代码冗余和拼写错误\n定义一个路径,拆分多种请求方式\n\n第一种方法\napp.all('/getUser',function(req,res,next){\n  res.header('Access-Control-Allow-Origin','*');\n  next();\n});\napp.route('/getUser').get().post();\napp.listen(8899);\n\n第二种方法 \nexpress.Router() 创建模块化、可挂载的路由\nvar express=require('express');\nvar app=express();\nvar router=express.Router();\nrouter.get('/src',function(req,res){\n  res.end('src')\n});\n//必须挂载至应用\napp.use([虚拟路径],router)\napp.listen(8899)\n\n\n===========================================\n中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。\n\n中间件的功能包括：\n\n执行任何代码。\n修改请求和响应对象。\n终结请求-响应循环。\n调用堆栈中的下一个中间件。\n如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。\n\nExpress 应用可使用如下几种中间件：\n\n应用级中间件\n路由级中间件\n错误处理中间件\n内置中间件\n第三方中间件\n使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。\n\n应用级中间件\n应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：\nvar app = express();\n\n// 没有挂载路径的中间件，应用的每个请求都会执行该中间件\napp.use(function (req, res, next) {\n  console.log('Time:', Date.now());\n  next();\n});\n\n// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求 (一级路径) 都会执行它\napp.use('/user/:id', function (req, res, next) {\n  console.log('Request Type:', req.method);\n  next();\n});\n\n// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求\napp.get('/user/:id', function (req, res, next) {\n  res.send('USER');\n});\n\n路由级中间件\n路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。\n\nvar router = express.Router();\n路由级使用 router.use() 或 router.VERB() 加载。\n\n上述在应用级创建的中间件系统，可通过如下代码改写为路由级：\n\nvar app = express();\nvar router = express.Router();\n\n// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件\nrouter.use(function (req, res, next) {\n  console.log('Time:', Date.now());\n  next();\n});\n\n// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息\nrouter.use('/user/:id', function(req, res, next) {\n  console.log('Request URL:', req.originalUrl);\n  next();\n}, function (req, res, next) {\n  console.log('Request Type:', req.method);\n  next();\n});\n\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\nrouter.get('/user/:id', function (req, res, next) {\n  // 如果 user id 为 0, 跳到下一个路由\n  if (req.params.id == 0) next('route');\n  // 负责将控制权交给栈中下一个中间件\n  else next(); //\n}, function (req, res, next) {\n  // 渲染常规页面\n  res.render('regular');\n});\n\n// 处理 /user/:id， 渲染一个特殊页面\nrouter.get('/user/:id', function (req, res, next) {\n  console.log(req.params.id);\n  res.render('special');\n});\n\n// 将路由挂载至应用\napp.use('/', router);\n\n错误处理中间件\n错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。\n\n错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。\n\n//当请求未注册路由时,该中间件会被执行 放在注册路由最下方\napp.use(function( req, res, next) {\n  res.status(404).send('Not Found!');\n});\n//当注册的路由中发生未预期异常时该中间件会被调用\napp.use(function(err, req, res, next) {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n---------------------------------------------\n完整版错误处理中间件\napp.use(function( req, res, next) {\n\tvar err=new Error('页面飞到外太空!');\n\terr.status=404;\n  \tnext(err);\n  \t//将控制权交给下一个错误处理中间件\n});\napp.use(function(err, req, res, next) {\n\tvar message=err.status?err.message:'服务器异常,请稍后再试!';\n  \tres.status(err.status||500).send(message');\n});\n\n//错误处理=应用级中间件(未注册路由)+错误处理中间件(路由中的异常);\n\n----------------------\n内置中间件\n内置中间件\n从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。\n\nexpress.static(root, [options])\nexpress.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。\n\n参数 root 指提供静态资源的根目录。该函数通过req.path和root目录来确定要提供的文件\n\n当找不到文件时,它不是发送404响应,而是调用next()继续下一个中间件\n\n可选的 options 参数拥有如下属性。\n\n属性\t描述\t类型\t缺省值\ndotfiles\t是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”\tString\t“ignore”\netag\t是否启用 etag 生成\tBoolean\ttrue\nextensions\t设置文件扩展名备份选项\tArray\t[]\nindex\t发送目录索引文件，设置为 false 禁用目录索引。\tMixed\t“index.html”\nlastModified\t设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。\tBoolean\ttrue\nmaxAge\t以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性。\tNumber\t0\nredirect\t当路径为目录时，重定向至 “/”。\tBoolean\ttrue\nsetHeaders\t设置 HTTP 头以提供文件的函数。\tFunction\t \n下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。\n\nvar options = {\n  dotfiles: 'ignore',\n  etag: false,\n  extensions: ['htm', 'html'],\n  index: false,\n  maxAge: '1d',\n  redirect: false,\n  setHeaders: function (res, path, stat) {\n    res.set('x-timestamp', Date.now());\n  }\n}\n\napp.use(express.static('public', options));\n每个应用可有多个静态目录。\n\napp.use(express.static('public'));\napp.use(express.static('uploads'));\napp.use(express.static('files'));\n\n-------------------\n第三方中间件 需下载\n通过使用第三方中间件从而为 Express 应用增加更多功能。\n\n安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。\n\nbodyParser 中间件用来解析http请求体\nbodyParser.urlencoded则用来解析我们通常的form表单提交的数据,当extended为false的时候,键值对中的值就为string或array形式\n")])])]),t("h3",{attrs:{id:"ejs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ejs","aria-hidden":"true"}},[n._v("#")]),n._v(" ejs")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("EJS是Javascript模板库,用来从JSON数据中生成HTML字符串\n\njs渲染\n//客户端向服务器发起文件请求(html css js) ==>服务器返回文件==>客户端解析文件标签==>客户端发起ajax请求==>服务器返回json==>客户端接收渲染\n\nejs\n//客户端向服务器发送请求==>服务器返回文件+json数据==>客户端渲染\n\n1、下载+引入 ejs  npm install ejs -S   \nvar express=require('express');\nvar path=require('path');\nvar app=express();\n//统一设置模板引擎路径\napp.set('views',path.resolve('view'));\n//统一设置模板引擎的类型(加后缀名)\napp.set('view engine','ejs');\napp.get('/',function(req,res){\n  \tres.render('index');\n  \t//res.render(path,{可选,传回的数据})默认将 . 解析为views路径\n})\napp.get('/list',function(req,res){\n  \tres.render('list');\n})\n\napp.locals 将值传递到所渲染的模板引擎中 (共有) 只能通过app.locals.key=val 来进行赋值\nres.locals 将值传递到所渲染的模板引擎中 (独属) 还可以通过res.locals={key:val} 来赋值\n\nejs语法\n<% js %> 解析js\n<%= data %> 转译输出\n<%- 'data' %> 非转译输出\n<%# 注释内容 %> 注释 \n<%- include('list',{可选,要传递的对象}) %>\n\n//将html转为ejs模板引擎\napp.engine('html',require('ejs').renderFile)\n")])])]),t("h3",{attrs:{id:"mysql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql","aria-hidden":"true"}},[n._v("#")]),n._v(" mysql")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("VARCHAR 字符串\nINT 整形 不给 默认11位\nDATE  年月日\nDATETIME 年月日时分秒\nid类型 INT  额外 auto_increment \n\nSQL语句-------------------\n\n增：\ninsert into 表名(列名，列名，列名) values(列值，列值，列值)，(列值，列值，列值)\n\n删：\ndelete from 表名 where 条件表达式===>age>10 ===>列名 关系符 值 \n多个条件之间已and 连接 条件一 and 条件二\n\n改：\nupdate 表名 set 列名=新值,列名=新值 where 条件表达式\n\n查：\n1、查询全部： select * from 表名   *代表全部的列\n2、查询某列： select 列名 from 表名\n3、按条件查询： select * from 表名 where 条件表达式 and 条2\n4、模糊查询：\n\t1) select * from 表名 where 列名 like \"%val%\" 查询带val的信息\n\t2) select * from 表名 where 列名 like \"val%\" 查询以val开头的信息\n\t3) select * from 表名 where 列名 like \"%val\" 查询以val结尾的信息\n5、限制条数查询\n\tselect * from 表名 limit 开始下标(0),查询长度 \n\t\n\t\n===============================================\n1、下载+引入mysql    npm install mysql -S\nvar mysql=require('mysql');\n2、创建连接对象\nvar options={\n  protocol:'http', ==> 默认 固定  协议\n  host:'localhost', ==> 默认 固定  域名\n  port:3306, ==> 默认 固定 端口号 \n  user:'root', ==> 必选  用户\n  password:'80645885', ==> string  密码\n  database:'1606lf' ==> 哪个数据库\n}\nvar con=mysql.createConnection(options);\n3、连接数据库\ncon.connect(function(err){\n  \tif(err){\n  \t\tthrow err;\n\t}\n});\n4、操作数据表\ncon.query(sql语句,[arr可选,当sql语句中出现问号时使用，每一项匹配每一项问号的值],function(err,result,filed){\n  \t//err 错误对象\n  \t//result 返回的结果集\n  \t5、与数据库断开连接\n  \tcon.end()\n})\n\n\n\nvar options={\n  protocol:'http', ==> 默认 固定  协议\n  host:'localhost', ==> 默认 固定  域名\n  port:3306, ==> 默认 固定 端口号 \n  user:'root', ==> 必选  用户\n  password:'80645885', ==> string  密码\n  database:'1606lf', ==> 哪个数据库\n  connectionLimit:10 ===> 连接对象的个数 默认为10\n}\n//创建连接池并且预先放入一定数量的连接对象\nvar pool=mysql.createPool(obj)\n//从连接池中取出连接对象\npool.getConnection(function(err,con){\n  \tif(err){\n  \t\treturn res.send(err.message);\n\t};\n\t//利用连接对象操作数据表\n\tcon.query(sql,function(err,result){\n  \t\tif(err){\n  \t\t\treturn res.send(err.message);\n  \t\t};\n  \t\t//将连接对象归还给连接池,以供下一次请求继续使用(释放连接对象)\n  \t\tcon.release();\n  \t\tres.end();\n\t})\n})\n\n连接池基本的思想是在系统初始化的时候,将数据库连接作为对象储存在内存中,当用户需要访问数据库时,并非建立一个新的连接,而是从连接池中取出一个已建立的空闲连接对象。使用完毕后,用户也并非将连接关闭,而是将连接放回到连接池中,以供下一个请求访问使用。\n")])])]),t("h3",{attrs:{id:"jsonp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jsonp","aria-hidden":"true"}},[n._v("#")]),n._v(" JSONP")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("同源策略:同协议 同域名 同端口\n解决：jsonp\n原理:利用script标签的src属性无跨域限制\n?callback=getData\n步骤:\n\t1、动态创建script标签\n\t2、指定src属性为某衣服武器地址,且src属性值+?callback=函数名\n\t3、将script标签追加到页面\n\t4、此时后台会提取去函数名并包裹数据返回,格式为:fn(data),所以要定义一个名为fn的函数接收后台响应值\n\n实现跨域访问\nres.jsonp();\n\njquery跨域方式 $.ajax $.getJSON\n$.ajax 的dataType 要设置成jsonp 会检索url 如果有?callback=? 则会把?替换成一个随机生成的戳 没有回默认加上?callback=? 在进行替换\njsonp 属性默认为callback 可以更改\n后台 cbName=req.url.solit('callback=')[1].split('&_=')[0];\n\n$.getJSON(服务器地址?callback=?,function(data){\n  \tconsole.log(data);\n})\n")])])]),t("p",[n._v("express应用生成器")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1、npm install express-generator -g\n2、express 文件夹名称\n")])])])])}],!1,null,null,null);e.default=s.exports}}]);